# Graphics {#action-graphics}

```{r, include = FALSE}
source("common.R")
```

```{r setup}
library(shiny)
library(ggplot2)
```

We talked briefly about `renderPlot()` in Chapter \@ref(basic-ui); it's a powerful tool for displaying graphics in your app. This chapter will show you how to use it to its full extent, including how to make your plots interactive. You'll also learn two important related functions: `renderCachedPlot()`, which speeds up your app by caching frequently used plots, and `renderImage()`, which allows you to serve images created in other ways.

## Interactivity

One of the neatest things about `plotOutput()` is that it can also be used as an input. It has four arguments (`click`, `dblClick`, `hover`, and `brush`) that allow you to set up input components that correspond to four common mouse events. These are used with `clickOpts()`, `dblclickOpts()`, `hoverOpts()` and `brushOpts()`. Designed to work with both base graphics and ggplot2.

These events can be divided into two types:

* Point events, `click`, `dblClick` and `hover` which have `x` and `y`
  events
  
* Rectangular event, `brush` has `xmin`, `xmax`, `ymin`, and `ymax`.






Helpers `nearPoints()` and `brushedPoints()`.

You can learn more at <https://shiny.rstudio.com/articles/plot-interaction.html>.  If you're looking for more general interactivity, you might also want to consider the plotly package, as documented in the book [_Interactive web-based data visualization with R, plotly, and shiny_](https://plotly-r.com), by Carson Sievert.

### Points


```{r}
ui <- basicPage(
  plotOutput("plot", click = clickOpts("click")),
  verbatimTextOutput("info")
)

server <- function(input, output) {
  output$plot <- renderPlot({
    plot(mtcars$wt, mtcars$mpg)
  })

  output$info <- renderPrint({
    str(input$click)
  })
}
```

Most important are `x` and `y` components that give the location of the event in data coordinates.


```{r}
ui <- fluidPage(
  plotOutput("plot", click = clickOpts("click")),
  tableOutput("data")
)
server <- function(input, output, session) {
  output$plot <- renderPlot(
    plot(mtcars$wt, mtcars$mpg)
  )
  
  output$data <- renderTable({
    nearPoints(mtcars, input$click, xvar = "wt", yvar = "mpg")
  })
}
```

`nearPoints(allRows = TRUE, addDist = TRUE)` to return all rows with distance; this allows you to rely on the distance calculations done by Shiny, but you can use the information in other ways.

### Rectangles



### Modifying data

To make interactive plots that modify the data, you'll need to use `reactiveValues()`. We'll come back to that later in Chapter XYZ. 

Here's one basic approach. Use `nearPoint()` to find which points are near the click. Then use `ifelse()` to toggle their values - that means clicking will both remove and re-add. 

```{r, eval = FALSE}
selected <- reactiveVal(rep(TRUE, nrow(mtcars)))

observeEvent(input$click, {
  clicked <- nearPoints(mtcars, input$click, allRows = TRUE)$selected_
  selected(ifelse(clicked, !selected(), selected()))
})
```

If you're plotting with ggplot2, you'll need to set the limits on the colour scale. Otherwise the colour scale will change after the first click because it gains a new level ("FALSE").

```{r}
ui <- fluidPage(
  plotOutput("plot", click = clickOpts("click")),
  tableOutput("data")
)
server <- function(input, output, session) {
  selected <- reactiveVal(rep(TRUE, nrow(mtcars)))
  
  output$plot <- renderPlot({
    mtcars$sel <- selected()
    ggplot(mtcars, aes(wt, mpg)) + 
      geom_point(aes(colour = sel)) +
      scale_colour_discrete(limits = c("TRUE", "FALSE"))
  })
  
  observeEvent(input$click, {
    clicked <- nearPoints(mtcars, input$click, allRows = TRUE)$selected_
    selected(ifelse(clicked, !selected(), selected()))
  })
}
```

### Dynamic height and width

One other useful trick. `height` and `width` can be zero-argument functions that return the size in pixels. These are evaluated in a reactive environment so that you can make the size of your plot dynamic.

Here's the basic idea:

```{r}
ui <- fluidPage(
  sliderInput("height", "height", min = 100, max = 500, value = 250),
  sliderInput("width", "width", min = 100, max = 500, value = 250),
  sliderInput("n", "n", min = 10, max = 100, value = 25),
  plotOutput("plot", width = 250, height = 250)
)
server <- function(input, output, session) {
  output$plot <- renderPlot(
    width = function() input$width,
    height = function() input$height,
    {
      plot(rnorm(input$n), rnorm(input$n))
    }
  )
}
```

Note that the plot is re-drawn, but the code is not rerun (i.e. the random values say the same). This is the same behaviour as when you resize a plot with a dynamic height/width (e.g. 100%).

In real cases, you'd use more complicated expressions in the `width` and `height` functions. For example, if you're using a faceted plot in ggplot2, you might use it to increase the size of the plot to keep the individual facet sizes roughly the same (unfortunately there's no easy way to keep them exactly the same because it's currently v. difficult to find out the size of the fixed elements around the borders of the plot.)

## `renderCachedPlot()`

Really useful if a plot is seen by multiple users, 

<https://shiny.rstudio.com/articles/plot-caching.html>

Mostly a matter of changing `renderPlot()` to `renderCachedPlot()`. But you also need to supply a `cacheKeyExpr`. This is some code that returns an object that basically represents the "state" of the plot; whenever that value changes, the plot will be recomputed.

BASIC EXAMPLE

### Cache key

Best to keep it as simple as possible - should be a list of vectors. 

* Input parameters.
* Dataset reactive. Avoid using very large datasets as a cache key - it
  will take some time
* Timestamp. `proc.time()[[3]] %/% 3600`

Also includes id, and plot size. Also implicitly depends on the current user.

### Sizing policy

Normally plots are rendered to the exact size needed. But that's not very useful for caching: if everyone has a slightly different sized plot, then the cache will never be used. `renderCachePlot()` resolves this problem by only caching plots with a fixed sizes and then resizing as needed. 

It uses an exponential rounding strategy determined by the `sizingPolicy` argument. It's unlikely that you'll need to tweak this, but if you do, see the `sizeGrowthRatio()` for details.

Another option worth considering is setting the plots to a fixed size by setting the `width` argument to `plotOutput` to a fixed unit like `"400px"` (the default `height` is already fixed). That will give you the best cache performance because every plot will have the same size.

### Scoping

By default, the plot cache is stored in memory, and shared across all users of the app. If needed, you can override these defaults with:

* `cache = "session"`: the cache lifetime will tied to a single user. It
  will be created when the session starts (i.e. when someone first visits
  you app), and deleted when the session ends. 
  
* `cache = diskCache(...)`: shares across multiple users, multiple     
  processes, and app-restarts. Beware that restarting the app will no 
  longer clear the cache, so if you change the plotting code, you'll also
  need to manually reset the cache by deleting the directory. 

It's also possible to store in a database, or right your own backend. See <https://shiny.rstudio.com/articles/plot-caching.html#can-i-write-my-own-caching-backend> for more details.

The default memory cache size of 10 MB can hold plenty of plots â€“ a cached plot object is typically between 50 and 250 kB. You can override with `shinyOptions(cache = memoryCache(size = 20e6))`.

## Images

If you need to display images that you already have saved on disk. These might come from an external source (maybe a directory of photographs), or perhaps you've generated them with another package (e.g. a 3d scene with`rgl::rgl.snapshot()`).

<https://shiny.rstudio.com/articles/images.html>

Unlike `renderPlot()`, `renderImage()` must return a list:

* `src`: (local) path to the image file. 

* `contentType` entry specifying the MIME type of the image. If one is not 
  provided, will try to detect the type from the file extension. You should
  only need to set this if you're generating images without file extensions,
  which generally you won't do.

* Other components like `width`, `height`

* `class`, `alt` will be added as attributes to the `<img>` tag.

### Static images

Sample app shows directory full of files.

`www/images`: another option is to put images in the `www/` directory. This is somewhat more efficient as it allows the browser to use caching automatically.

`?shiny::addResourcePath`

> Static files under the www/ directory are automatically made available under a request path that begins with /.

Then use `img()` + `renderUI()` to generate img tags.

### Dynamic images

In most cases, you're better off figuring out how to use `renderPlot()` because it takes care of so many details for you, it's easily cached, and the vast majority of R packages that generate images already provided some way to .

* Note the `deleteFile` argument. Set it to `TRUE` if you're rendering the image live, and it should be deleted after its been sent to the user. `outfile <- tempfile(fileext = '.png')`

* You can detect the size of the plot in the browserwith `session$clientData$output_myImage_width` and `session$clientData$output_myImage_height`. (This works for all outputs, but isn't usually needed. ) Also `session$clientData$pixelratio`.



## Exercises

1. Make a plot with click, dblclick, hover, and brush output handlers
   and nicely display the current selection in the sidebar. Plot the 
   plot in the main panel.
